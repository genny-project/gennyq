package life.genny.qwandaq.capabilities;

import java.lang.invoke.MethodHandles;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.jboss.logging.Logger;

import life.genny.qwandaq.attribute.Attribute;
import life.genny.qwandaq.constants.Prefix;
import life.genny.qwandaq.datatype.capability.core.CapabilityBuilder;
import life.genny.qwandaq.datatype.capability.core.node.CapabilityNode;
import life.genny.qwandaq.entity.BaseEntity;
import life.genny.qwandaq.exception.checked.RoleException;
import life.genny.qwandaq.exception.runtime.ItemNotFoundException;
import life.genny.qwandaq.utils.BaseEntityUtils;
import life.genny.qwandaq.utils.CommonUtils;

public class RoleBuilder {
    private static final Logger log = Logger.getLogger(MethodHandles.lookup().lookupClass());
    
    private CapabilitiesController controller;
    private RoleManager roleMan;
    private BaseEntityUtils beUtils;

    private final BaseEntity targetRole;
    
    private final String productCode;

    private final List<BaseEntity> inheritedRoles = new ArrayList<>();

    private final List<String> childrenCodes = new ArrayList<>();

    /**
     * A map from Attribute (Capability) Code to Attribute (Capability)
     */
    private Map<String, Attribute> capabilityMap;

    /**
     * A map from Capability Code to Capabilities to add to the role for that Capability
     */
    private Map<String, CapabilityNode[]> roleCapabilities = new HashMap<>();

    private String redirectCode;

    private boolean shouldBuild = true;

    public RoleBuilder(String roleCode, String roleName, String productCode) {
        initCDI();

        this.productCode = productCode;
        targetRole = roleMan.createRole(productCode, roleCode, roleName);

        // create role will return a base entity with no capability attributes so far
        // if it doesn't already exist. If any do exist I am willing to assume we are running on startup
        // again and shouldn't need to repersist the roles.

        // TODO: Finish implementing this mechanism once rest of capabilities revision works
        boolean hasCapabilities = targetRole.getBaseEntityAttributes().stream().anyMatch(ea -> ea.getAttributeCode().startsWith(Prefix.CAP_));
        shouldBuild = !hasCapabilities;
    }

    /**
     * This is a non-cdi class that needs to make use of cdi beans. New instances of it
     * get created on the fly as necessary, so it is hard to find a scope for it
     */
    private void initCDI() {
        this.controller = CommonUtils.getArcInstance(CapabilitiesController.class);
        this.roleMan = controller.getRoleManager();
        this.beUtils = CommonUtils.getArcInstance(BaseEntityUtils.class);
    }

    /**
     * Set the {@link RoleBuilder#capabilityMap}
     * @param capabilityMap - the map generated by {@link CapEngine#getCapabilityMap}
     * @return this RoleBuilder
     * 
     * @see {@link CapEngine#getCapabilityAttributeMap(String, String[][])}
     */
    public RoleBuilder setCapabilityMap(Map<String, Attribute> capabilityMap) {
        this.capabilityMap = capabilityMap;
        return this;
    }

    public RoleBuilder setRoleRedirect(String redirectCode) {
        this.redirectCode = redirectCode;
        return this;
    }

    /**
     * Add one or more roles for this role to inherit
     * @param otherRoles - other role base entities
     * @return
     */
    public RoleBuilder inheritRole(BaseEntity... otherRoles) {
        inheritedRoles.addAll(Arrays.asList(otherRoles));
        return this;
    }

    /**
     * Start creating a capability and add it when it is finished building
     * @param capabilityCode
     * @return
     */
    public CapabilityBuilder addCapability(String capabilityCode) {
        fetch(capabilityCode);
        return new CapabilityBuilder(this, capabilityCode);
    }

    public RoleBuilder addChildren(String... roleCodes) {
        this.childrenCodes.addAll(Arrays.asList(roleCodes));
        return this;
    }

    public Map<String, CapabilityNode[]> getCapabilities() {
        return roleCapabilities;
    }

    public BaseEntity build() throws RoleException {
        if(capabilityMap == null) {
            throw new RoleException("Capability Map not set. Try using setCapabilityMap(Map<String, Attribute> capabilityMap) before building.");
        }
        boolean controllerPersistState = controller.willPersist();
        controller.doPersist(false);

        // Redirect
        roleMan.setRoleRedirect(productCode, targetRole, redirectCode);

        // Capabilities
        for(Entry<String, CapabilityNode[]> capabilityEntry : roleCapabilities.entrySet()) {
            String code = capabilityEntry.getKey();
            CapabilityNode[] nodes = capabilityEntry.getValue();
            controller.addCapability(productCode, targetRole, fetch(code), nodes);
        }

        // Role inherits
        for(BaseEntity parentRole : this.inheritedRoles) {
            roleMan.inheritRole(productCode, targetRole, parentRole);
        }
        
        // Children
        roleMan.setChildren(productCode, targetRole, childrenCodes.toArray(new String[0]));

        // We aren't persisting on each call to addCapability, so persist
        // going to experiment with persisting once here
        beUtils.updateBaseEntity(productCode, targetRole);

        controller.doPersist(controllerPersistState);
        return targetRole;
    }

	private Attribute fetch(String attrCode) throws ItemNotFoundException {
        attrCode = CapabilitiesController.cleanCapabilityCode(attrCode);
		Attribute attribute = capabilityMap.get(attrCode);
		if(attribute == null) {
			log.warn("Could not find capability in map: " + attrCode + ". Add to it to the map to create it.");
			throw new ItemNotFoundException("capability map", attrCode);
		}
		return attribute;
	}
}
